import std/[sequtils]
import sigil
import sigil/codex
import sigil/sigir
import sigil/sigvm
import sigil/combinators
import sigil/sigir/compiler

type 
  TestCtx = object
    # User data to verify side-effects
    captured: seq[string]

  TestGroups = enum tgNone, tgVal

  # Generic Type Aliases
  RB = RuleBuilder[TestCtx, TestGroups, char, true]
  MyCtx = ParserCtx[TestCtx, TestGroups, char, true]
  MyRule = Rule[TestCtx, TestGroups, char, true]

# Helper to run VM with static compilation
template runTest(
  p: static MyRule, 
  input: string
): (VmResult, MyCtx) =
  # 1. Compile at CT
  const glyph = compile(p)
  
  # 2. Init Context
  var ctx = MyCtx() 
  
  # 3. Convert input string -> seq[char] (The VM expects seq[A])
  let inputSeq = @input
  
  # 4. Run
  let res = run[TestCtx, TestGroups, char, true](glyph, inputSeq, ctx)
  (res, ctx)

block BasicExecution:
  const p = RB.define("Main", RB.match("hello"))
  let (res, _) = runTest(p, "hello")
  doAssert res.success
  doAssert res.matchLen == 5
  
  let (resFail, _) = runTest(p, "hell")
  doAssert not resFail.success

block InvertedChar:
  const p = RB.define("NotA", RB.noMatch('a'))

  let (res, _) = runTest(p, "b")
  doAssert res.success
  doAssert res.matchLen == 1

  let (resFail, _) = runTest(p, "a")
  doAssert not resFail.success
  
  # Fix: Check for the actual error message generated by the VM
  doAssert "Not a" in resFail.expectedTerminals

block SetMatching:
  const p = RB.define("Digit", RB.match({'0'..'9'}))

  let (res, _) = runTest(p, "7")
  doAssert res.success
  doAssert res.matchLen == 1

  let (resFail, _) = runTest(p, "a")
  doAssert not resFail.success
  # Set ranges are pretty printed
  doAssert "[0-9]" in resFail.expectedTerminals

block InvertedSet:
  const p = RB.define("NotDigit", RB.noMatch({'0'..'9'}))

  let (res, _) = runTest(p, "a")
  doAssert res.success

  let (resFail, _) = runTest(p, "5")
  doAssert not resFail.success
  doAssert "Not [0-9]" in resFail.expectedTerminals

block ChoiceBacktracking:
  const p = RB.define("Main", 
    (RB.match('a') and RB.match('b')) or 
    (RB.match('a') and RB.match('c'))
  )
  
  let (res, _) = runTest(p, "ac")
  doAssert res.success
  doAssert res.matchLen == 2

block Loops:
  # 'const' required for static compilation helper
  const p = RB.define("Main", many0(RB.match('a')))
  
  let (res, _) = runTest(p, "aaab")
  doAssert res.success
  doAssert res.matchLen == 3

block RecursionRuntime:
  # We construct the rule in a const block so it's available at CT
  const p = block:
    var r = RB.define("P")
    let body = (RB.match('a') and call(r) and RB.match('a')) or RB.match('b')
    r.implement(body)
    r
  
  let (res1, _) = runTest(p, "b")
  doAssert res1.success
  
  let (res2, _) = runTest(p, "aba")
  doAssert res2.success
  
  let (res3, _) = runTest(p, "aabaa")
  doAssert res3.success
  
  let (resFail, _) = runTest(p, "aaba")
  doAssert not resFail.success

block PositiveLookahead:
  const p = RB.define("Main", 
    peek(RB.match('a')) and RB.match('a')
  )
  
  let (res, _) = runTest(p, "a")
  doAssert res.success
  doAssert res.matchLen == 1
  
  let (resFail, _) = runTest(p, "b")
  doAssert not resFail.success

block NegativeLookahead:
  const p = RB.define("Main", 
    reject(RB.match('a')) and RB.any()
  )
  
  let (res, _) = runTest(p, "b")
  doAssert res.success
  
  let (resFail, _) = runTest(p, "a")
  doAssert not resFail.success

block NestedLookaheadStackCleanliness:
  const inner = peek(RB.match('a'))
  const p = RB.define("Main", reject(inner))
  
  let (res, _) = runTest(p, "b")
  doAssert res.success

# --- New Pipeline Tests (Updated for Accumulator Channels) ---

block Siphoning:
  # Siphons into 'tgVal' channel
  const p = RB.define("Main", RB.match('a').siphon(tgVal))
  
  let (res, ctx) = runTest(p, "a")
  doAssert res.success
  
  # Channel type is now seq[seq[char]]
  doAssert ctx.channels[tgVal].len == 1    # One capture made
  doAssert ctx.channels[tgVal][0] == @['a'] # Capture #0 is "a"

block AbsorbExecution:
  # Define the Absorb callback (Typed)
  proc myAbsorb(ctx: var MyCtx): bool =
    # Read from channel (seq[seq[char]])
    let captures = ctx.channels[tgVal]
    
    # Process all accumulated captures
    for cap in captures:
      ctx.ext.captured.add(cast[string](cap)) # cast seq[char] -> string
    
    return true

  const p = RB.define("Main", 
    # Match 'a', siphon it to tgVal, then absorb (trigger callback)
    RB.match('a').siphon(tgVal).absorb(myAbsorb.AbsorbProc)
  )
 
  let (res, ctx) = runTest(p, "ab")
  
  doAssert res.success
  doAssert ctx.ext.captured.len == 1 
  doAssert ctx.ext.captured[0] == "a"

block AbsorbFailureBacktracking:
  proc failAbsorb(ctx: var MyCtx): bool =
    return false

  const p = RB.define("Main", 
    (RB.match('a').absorb(failAbsorb)) or 
    (RB.match('a') and RB.match('b'))
  )

  let (res, _) = runTest(p, "ab")
  doAssert res.success
  doAssert res.matchLen == 2

block ErrorReporting:
  const p = RB.define("Main", RB.match('a') and RB.match('b'))
  let (res, _) = runTest(p, "ac")
  
  doAssert not res.success
  doAssert res.furthestFailureIdx == 1
  doAssert res.foundTerminal == "`c`" 
  # Check failure messages (pretty printed)
  doAssert "b" in res.expectedTerminals

block CustomErrorLabels:
  const p = RB.define("Main", errorLabel(RB.match('a'), "Expected Alpha"))
  
  let (res, _) = runTest(p, "b")
  doAssert not res.success
  
  doAssert res.foundTerminal == "`b`"
  doAssert "Expected Alpha" in res.expectedTerminals
  doAssert "'a'" notin res.expectedTerminals